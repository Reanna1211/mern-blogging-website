import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import mongoose from 'mongoose';
import 'dotenv/config';
import bcrypt from "bcryptjs";

// nanoid will give a random unique string
import { nanoid } from 'nanoid';

// this will create a long string, to give access tokens to allow client permissions to change or update their profile
import jwt from 'jsonwebtoken';


// Schema below
import User from './Schema/User.js';

// To get the current directory (replaces __dirname in ES modules)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();

// Serve static files from the frontend's dist folder
app.use(express.static(path.resolve(__dirname, '../blogging website - frontend/dist')));

// Handle all requests by sending index.html
app.get('*', (req, res) => {
  res.sendFile(path.resolve(__dirname, '../blogging website - frontend/dist', 'index.html'));
});

const PORT = process.env.PORT || 5001;

let emailRegex = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/; // regex for email
let passwordRegex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,20}$/; // regex for password

app.use(express.json())

mongoose.connect(process.env.DB_LOCATION, {
  autoIndex: true
})

const formatDatatoSend = (user) => {
  //user._id is an id generated from MongoDB
  // the first argument of jwt.sign is what data we have to convert and second argument is a long private key to use as an algorithm to convert it into a hashing

  const access_token = jwt.sign({ id: user._id }, process.env.SECRET_ACCESS_KEY)

  return {
    access_token,
    profile_img: user.personal_info.profile_img,
    username: user.personal_info.username,
    fullname: user.personal_info.fullname
  }
}



// to give error message that username is already taken and to allow user to change username if username created from their email already exists, change to username that has a random number added to it
const generateUsername = async (email) => {
  let username = email.split("@")[0] // 'example: 'as@gmail.com' -> [as, gmail] -> as
  let isUsernameNotUnique = await User.exists({ "personal_info.username": username }).then((result) => result)

  // we add .substring(0, 5) just to give a shorter version of the random letters and numbers strign generated by nanoid
  isUsernameNotUnique ? username += nanoid().substring(0, 5) : "";

  return username
}


app.post("/signup", (req, res) => {

  let {fullname, email, password} = req.body

  if (fullname.length < 3) {
      return res.status(403).json({ "error": "Fullname must be at least 3 letters long" })
  }
  // !email.length means if email length is 0 for example not entered, therefore is no length, it will give an error
  if (!email.length ) {
    return res.status(403).json({ "error": "Enter email"})
  }
  if (!emailRegex.test(email)) {
    return res.status(403).json({ "error": "Email is invalid"})
  }

  if (!passwordRegex.test(password)) {
    return res.status(403).json({ "error": "Password be 6 to 20 characters long with a numeric, 1 lowercase and 1 uppercase letters"})
  }

  //Have to make this function async as well as generateUsername is an asynchronous function and this function will await generateUsername function
  bcrypt.hash(password, 10, async (err, hashed_password) => {

    let username = await generateUsername(email); 

    // saves user information in the database using the user.js schema
    let user = new User({
      personal_info: { fullname, email, password: hashed_password, username }
    })
      
    user.save().then((u) => {
      return res.status(200).json(formatDatatoSend(u))
    })

    .catch(err => {

      if(err.code == 11000) {
        return res.status(500).json({ "error": "Email already exists"})
      }
      return res.status(500).json({ "error": err.message})
    })

  })
})

app.post("/signin", (req, res) => {
  let { email, password } = req.body;

  User.findOne({ "personal_info.email": email})
  .then((user) => {
    if(!user){
      return res.status(403).json({ "error": "Email not found"})
    }

    bcrypt.compare(password, user.personal_info.password, (err, result) => {

      if(err) {
        return res.status(403).json({ "error": "Error occurred while logging in, please try again."})
      }

      if(!result){
        return res.status(403).json({ "error": "Incorrect password "})

      } else {
        return res.status(200).json(formatDatatoSend(user))
      }

    })


    
    
  })
  .catch(err => {
    console.log(err.message);
    return res.status(500).json({ "error": err.message })
  })
})

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});



